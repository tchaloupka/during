<!DOCTYPE html>
<html lang="en">
<head>
        <title>SubmissionEntryFlags (during.io_uring.SubmissionEntryFlags)</title>
	<meta charset="utf-8" />
	<meta content="width=device-width, initial-scale=1" name="viewport" />
        <link href="style.css" rel="stylesheet" />
        <script src="script.js" type="text/javascript"></script>

	
	<link href="search-results.html" rel="prefetch" />
</head>
<body>
	<div id="page-header">
		<div id="logotype">
		<span>Documentation</span>
		<nav>
			<a href="http://dlang.org/">Dlang.org</a>
		</nav>
		</div>

		<form action="search-docs.html" id="search">
			<input name="searchTerm" placeholder="Find a symbol name..." type="search" />
			<input type="submit" value="Go" />
		</form>
	</div>
	<div id="page-body">
		<div id="page-content">
		<h1>SubmissionEntryFlags</h1><div class="breadcrumbs"><a class="breadcrumb" href="during.html">during</a> <a class="breadcrumb" href="during.io_uring.html">io_uring</a> </div><div><div class="documentation-comment synopsis"><div><p>sqe-&gt;flags</p></div></div></div><div class="annotated-prototype"></div><h2 id="values"><a class="header-anchor" href="#values">Values</a></h2><table class="enum-members"><tr><th>Value</th><th>Meaning</th></tr><tr class="enum-member" id="NONE"><td><a class="enum-member-name" href="#NONE">NONE</a><span class="enum-member-value"><tt class="highlighted"><span class="num">0</span></tt></span><div class="enum-attributes"></div></td><td><div></div></td></tr><tr class="enum-member" id="FIXED_FILE"><td><a class="enum-member-name" href="#FIXED_FILE">FIXED_FILE</a><span class="enum-member-value"><tt class="highlighted"><span class="num">1U</span> &lt;&lt; <span class="num">0</span></tt></span><div class="enum-attributes"></div></td><td><div><p>Use fixed fileset (<tt class="inline-code">IOSQE_FIXED_FILE</tt>) When this flag is specified, fd is an index into the files array registered with the io_uring instance (see the <tt class="inline-code">IORING_REGISTER_FILES</tt> section of the io_uring_register(2) man page).</p></div></td></tr><tr class="enum-member" id="IO_DRAIN"><td><a class="enum-member-name" href="#IO_DRAIN">IO_DRAIN</a><span class="enum-member-value"><tt class="highlighted"><span class="num">1U</span> &lt;&lt; <span class="num">1</span></tt></span><div class="enum-attributes"></div></td><td><div><p><tt class="inline-code">IOSQE_IO_DRAIN</tt>: issue after inflight IO</p><p>If a request is marked with <tt class="inline-code">IO_DRAIN</tt>, then previous commands must complete before this one
is issued. Subsequent requests are not started until the drain has completed.</p><p>Note: available from Linux 5.2</p></div></td></tr><tr class="enum-member" id="IO_LINK"><td><a class="enum-member-name" href="#IO_LINK">IO_LINK</a><span class="enum-member-value"><tt class="highlighted"><span class="num">1U</span> &lt;&lt; <span class="num">2</span></tt></span><div class="enum-attributes"></div></td><td><div><p><tt class="inline-code">IOSQE_IO_LINK</tt></p><p>If set, the next SQE in the ring will depend on this SQE. A dependent SQE will not be started
until the parent SQE has completed. If the parent SQE fails, then a dependent SQE will be
failed without being started. Link chains can be arbitrarily long, the chain spans any new
SQE that continues tohave the IOSQE_IO_LINK flag set. Once an SQE is encountered that does
not have this flag set, that defines the end of the chain. This features allows to form
dependencies between individual SQEs.</p><p>Note: available from Linux 5.3</p></div></td></tr><tr class="enum-member" id="IO_HARDLINK"><td><a class="enum-member-name" href="#IO_HARDLINK">IO_HARDLINK</a><span class="enum-member-value"><tt class="highlighted"><span class="num">1U</span> &lt;&lt; <span class="num">3</span></tt></span><div class="enum-attributes"></div></td><td><div><p><tt class="inline-code">IOSQE_IO_HARDLINK</tt> - like LINK, but stronger</p><p>Some commands will invariably end in a failure in the sense that the
completion result will be less than zero. One such example is timeouts
that don't have a completion count set, they will always complete with
<tt class="inline-code">-ETIME</tt> unless cancelled.</p><p>For linked commands, we sever links and fail the rest of the chain if
the result is less than zero. Since we have commands where we know that
will happen, add IOSQE_IO_HARDLINK as a stronger link that doesn't sever
regardless of the completion result. Note that the link will still sever
if we fail submitting the parent request, hard links are only resilient
in the presence of completion results for requests that did submit
correctly.</p><p>Note: available from Linux 5.5</p></div></td></tr><tr class="enum-member" id="ASYNC"><td><a class="enum-member-name" href="#ASYNC">ASYNC</a><span class="enum-member-value"><tt class="highlighted"><span class="num">1U</span> &lt;&lt; <span class="num">4</span></tt></span><div class="enum-attributes"></div></td><td><div><p><tt class="inline-code">IOSQE_ASYNC</tt></p><p>io_uring defaults to always doing inline submissions, if at all possible. But for larger
copies, even if the data is fully cached, that can take a long time. Add an IOSQE_ASYNC flag
that the application can set on the SQE - if set, it'll ensure that we always go async for
those kinds of requests.</p><p>Note: available from Linux 5.6</p></div></td></tr><tr class="enum-member" id="BUFFER_SELECT"><td><a class="enum-member-name" href="#BUFFER_SELECT">BUFFER_SELECT</a><span class="enum-member-value"><tt class="highlighted"><span class="num">1U</span> &lt;&lt; <span class="num">5</span></tt></span><div class="enum-attributes"></div></td><td><div><p><tt class="inline-code">IOSQE_BUFFER_SELECT</tt>
If a server process has tons of pending socket connections, generally it uses epoll to wait
for activity. When the socket is ready for reading (or writing), the task can select a buffer
and issue a recv/send on the given fd.</p><p>Now that we have fast (non-async thread) support, a task can have tons of pending reads or
writes pending. But that means they need buffers to back that data, and if the number of
connections is high enough, having them preallocated for all possible connections is
unfeasible.</p><p>With IORING_OP_PROVIDE_BUFFERS, an application can register buffers to use for any request.
The request then sets IOSQE_BUFFER_SELECT in the sqe, and a given group ID in sqe-&gt;buf_group.
When the fd becomes ready, a free buffer from the specified group is selected. If none are
available, the request is terminated with -ENOBUFS. If successful, the CQE on completion will
contain the buffer ID chosen in the cqe-&gt;flags member, encoded as:</p><p><tt class="inline-code">(buffer_id &lt;&lt; IORING_CQE_BUFFER_SHIFT) | IORING_CQE_F_BUFFER;</tt></p><p>Once a buffer has been consumed by a request, it is no longer available and must be
registered again with IORING_OP_PROVIDE_BUFFERS.</p><p>Requests need to support this feature. For now, IORING_OP_READ and IORING_OP_RECV support it.
This is checked on SQE submission, a CQE with res == -EOPNOTSUPP will be posted if attempted
on unsupported requests.</p><p>Note: available from Linux 5.7</p></div></td></tr></table><div><h2 id="meta"><a class="header-anchor" href="#meta">Meta</a></h2><div class="documentation-comment source-section other-section"><h3 id="source"><a class="header-anchor" href="#source">Source</a></h3><div><p><a href="source/during.io_uring.d.html#L409">See Implementation</a><br /></p></div></div></div></div>
		<div id="page-nav"><a class="parent" href="during.html">during</a> <a class="parent" href="during.io_uring.html">io_uring</a> 
		<span class="type-separator">enums</span><ul><li><a class="enum" href="during.io_uring.AcceptFlags.html">AcceptFlags</a></li><li><a class="enum" href="during.io_uring.CQEFlags.html">CQEFlags</a></li><li><a class="enum" href="during.io_uring.CQRingFlags.html">CQRingFlags</a></li><li><a class="enum" href="during.io_uring.EnterFlags.html">EnterFlags</a></li><li><a class="enum" href="during.io_uring.MsgFlags.html">MsgFlags</a></li><li><a class="enum" href="during.io_uring.Operation.html">Operation</a></li><li><a class="enum" href="during.io_uring.PollEvents.html">PollEvents</a></li><li><a class="enum" href="during.io_uring.RegisterOpCode.html">RegisterOpCode</a></li><li><a class="enum" href="during.io_uring.SetupFeatures.html">SetupFeatures</a></li><li><a class="enum" href="during.io_uring.SetupFlags.html">SetupFlags</a></li><li><a class="enum current" href="during.io_uring.SubmissionEntryFlags.html">SubmissionEntryFlags</a></li><li><a class="enum" href="during.io_uring.SyncFileRangeFlags.html">SyncFileRangeFlags</a></li><li><a class="enum" href="during.io_uring.TimeoutFlags.html">TimeoutFlags</a></li></ul><span class="type-separator">functions</span><ul><li><a class="function" href="during.io_uring.io_uring_enter.html">io_uring_enter</a></li><li><a class="function" href="during.io_uring.io_uring_register.html">io_uring_register</a></li><li><a class="function" href="during.io_uring.io_uring_setup.html">io_uring_setup</a></li></ul><span class="type-separator">manifest constants</span><ul><li><a class="manifest-constant" href="during.io_uring.IO_URING_OP_SUPPORTED.html">IO_URING_OP_SUPPORTED</a></li><li><a class="manifest-constant" href="during.io_uring.SPLICE_F_FD_IN_FIXED.html">SPLICE_F_FD_IN_FIXED</a></li></ul><span class="type-separator">structs</span><ul><li><a class="struct" href="during.io_uring.CompletionEntry.html">CompletionEntry</a></li><li><a class="struct" href="during.io_uring.CompletionQueueRingOffsets.html">CompletionQueueRingOffsets</a></li><li><a class="struct" href="during.io_uring.KernelTimespec.html">KernelTimespec</a></li><li><a class="struct" href="during.io_uring.SetupParameters.html">SetupParameters</a></li><li><a class="struct" href="during.io_uring.SubmissionEntry.html">SubmissionEntry</a></li><li><a class="struct" href="during.io_uring.SubmissionQueueRingOffsets.html">SubmissionQueueRingOffsets</a></li></ul></div>
	</div>
	<div id="page-footer">Page generated by <a href="https://github.com/adamdruppe/adrdox">adrdox</a></div>
</body>
</html>